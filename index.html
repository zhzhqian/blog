## arm boot

#### 启动的内容一般包括：

1. 初始化中断向量
2. 初始化寄存器
3. 配置mmu和cache
4. 使能Neon和浮点运算
5. 改变异常等级

#### 初始化中断向量

包括：1.设置中断向量表、2.异步中断的绕线和屏蔽配置

aarch64的复位向量不在是异常向量的一部分，有专门的配置引脚和寄存器来负责复位向量。其他的异常向量存在异常向量表里面

**复位向量：** aarch64，寄存器从一个自定义的地址开始执行（通过硬件输入引脚RVBARADDR决定），可以通过读取RVBAR_EL3寄存器来获得。

**异常向量表：**

有三个异常向量表VBAR_EL3、VBAR_EL2、VBAR_EL1，每一个表有16项，每一项128B（最多32条指令），异常向量表必须放置在2KB-aligned address，将这个地址填入VBAR_ELn寄存器。

初始化的代码

```assembly
// Initialize VBAR_EL3.
LDR X1, = vector_table_el3
MSR VBAR_EL3, X1
LDR X1, = vector_table_el2
MSR VBAR_EL2, X1
LDR X1, = vector_table_el1
MSR VBAR_EL1, X1
```

一个典型的异常向量表，这里解释了 ELx_SP0是什么

```
// Typical exception vector table code.
.balign 0x800
Vector_table_el3:
curr_el_sp0_sync: // The exception handler for the synchronous
 // exception from the current EL using SP0.
.balign 0x80
curr_el_sp0_irq: // The exception handler for the IRQ exception
 // from the current EL using SP0.
.balign 0x80
curr_el_sp0_fiq: // The exception handler for the FIQ exception
 // from the current EL using SP0.
.balign 0x80
curr_el_sp0_serror: // The exception handler for the system error 
 // exception from the current EL using SP0.
.balign 0x80
curr_el_spx_sync: // The exception handler for the synchronous
 // exception from the current EL using the
 // current SP.
.balign 0x80
curr_el_spx_irq: // The exception handler for IRQ exception 
 // from the current EL using the current SP.
 .balign 0x80
curr_el_spx_fiq: // The exception handler for the FIQ exception 
 // from the current EL using the current SP.
 
.balign 0x80
curr_el_spx_serror: // The exception handler for the system error 
 // exception from the current EL using the
 // current SP.
.balign 0x80
lower_el_aarch64_sync: // The exception handler for the synchronous
 // exception from a lower EL (AArch64).
 
.balign 0x80
lower_el_aarch64_irq: // The exception handler for the IRQ exception 
 // from a lower EL (AArch64).
.balign 0x80
lower_el_aarch64_fiq: // The exception handler for the FIQ exception 
 // from a lower EL (AArch64).
.balign 0x80
lower_el_aarch64_serror: // The exception handler for the system error 
 // exception from a lower EL(AArch64).
.balign 0x80
lower_el_aarch32_sync: // The exception handler for the synchronous
 // exception from a lower EL(AArch32).
.balign 0x80
lower_el_aarch32_irq: // The exception handler for the IRQ exception 
 // from a lower EL (AArch32).
.balign 0x80
lower_el_aarch32_fiq: // The exception handler for the FIQ exception 
 // from a lower EL (AArch32).
.balign 0x80
lower_el_aarch32_serror: // The exception handler for the system error
 // exception from a lower EL(AArch32).
```

**使能异步中断：**

异步中断包括SError，IRQ和FIQ，reset时默认是被屏蔽的

SError是用内存发出的异常，之所以称为异步的，是因为当内部发出时，该指令可能已经执行完或者被刷掉了（推测执行），一般是在MMU检测没问题，但是访存的时候出了问题，比如校验码错了

异步异常的绕线，这决定了处理异步异常时的异常等级（EL1,EL2,EL3），为了使得异步异常由EL3执行，需要设置SCR_EL3.{EA,IRQ,FIQ}

```assembly
MRS X0, SCR_EL3
ORR X0, X0, #(1<<3) // The EA bit.
ORR X0, X0, #(1<<1) // The IRQ bit.
ORR X0, X0, #(1<<2) // The FIQ bit.
MSR SCR_EL3, X0
```

如果要让异步异常由EL2执行，需要设置HCR_EL2.{AMO,FMO,IMO} and clear SCR_EL3.{EA,IRQ,FIQ}

```assembly
MRS X0, HCR_EL2
ORR X0, X0, #(1<<5) // The AMO bit.
ORR X0, X0, #(1<<4) // The IMO bit.
ORR X0, X0, #(1<<3) // The FMO bit.
MSR HCR_EL2, X0
```

如果中断没有设置为EL2或者EL3，会被默认为由EL1处理

**异步中断的屏蔽：**
一个异步中断是否屏蔽取决于：

1. 处理该异步中断的目标异常等级
2. PSTATE.{A,I,F}值

当设置的处理异步中断的异常等级低于当前等级时，中断会被自动屏蔽

当设置的处理异步中断的异常等级等于当前等级时，PSTATE.{A,I,F}值为1则被屏蔽

设置的处理异步中断的异常等级高于当前等级时，屏蔽自动打开

设置的处理异步中断的异常等级高于当前等级，并且设置的处理异步中断的异常等级为EL1，PSTATE.{A,I,F}值为1则被屏蔽

#### 初始化寄存器：

寄存器的初始化包括初始化：

1. 通用寄存器
2. 栈寄存器
3. 系统控制寄存器

**通用寄存器初始化：**

实际上是不需要的，只有在仿真的时候需要

**初始化SP:**

要考虑多核情况下，考虑不同的异常等级下不同的栈所占内存的分布。

```assembly
// Initialize the stack pointer.
ADR X1, stack_top
ADD X1, X1, #4
MRS X2, MPIDR_EL1
AND X2, X2, #0xFF // X2 == CPU number.
MOV X3, #CPU_STACK_SIZE
MUL X3, X2, X3 // Create separated stack spaces 
SUB X1, X1, X3 // for each processor
MOV SP, X1
```

**初始化系统控制寄存器：**

有一些系统寄存器没有体系结构reset值，因此你必须基于软件需求初始化寄存器。

理论上，你需要为所有没有reset值的寄存器初始化，但是有些寄存器有实现特定的一些reset值，所以最好看手册： ARM® Architecture Reference Manual ARMv8, for ARMv8-A architecture profile的系统寄存器部分

#### 配置MMU

包括：

1. 清除并且invalidate cahce
2. 设置MMU
3. 使能MMU和caches

**invalidate cache：**

reset后cache会自动invalidate，所以可以不用invalidate cache，但是在powerdown process后需要？？。

```assembly
// Disable L1 Caches
MRS X0, SCTLR_EL3 // Read SCTLR_EL3.
BIC X0, X0, #(0x1 << 2) // Disable D Cache.
MSR SCTLR_EL3, X0 // Write SCTLR_EL3.
// Invalidate Data cache to make the code general purpose. 
// Calculate the cache size first and loop through each set +
// way.
MOV X0, #0x0 // X0 = Cache level 
MSR CSSELR_EL1, x0 // 0x0 for L1 Dcache 0x2 for L2 Dcache.
MRS X4, CCSIDR_EL1 // Read Cache Size ID.
AND X1, X4, #0x7
ADD X1, X1, #0x4 // X1 = Cache Line Size.
LDR X3, =0x7FFF
AND X2, X3, X4, LSR #13 // X2 = Cache Set Number – 1.
LDR X3, =0x3FF
AND X3, X3, X4, LSR #3 // X3 = Cache Associativity Number – 1.
CLZ W4, W3 // X4 = way position in the CISW instruction.
MOV X5, #0 // X5 = way counter way_loop.
way_loop:
MOV X6, #0 // X6 = set counter set_loop.
set_loop:
LSL X7, X5, X4
ORR X7, X0, X7 // Set way.
LSL X8, X6, X1
ORR X7, X7, X8 // Set set.
DC cisw, X7 // Clean and Invalidate cache line.
ADD X6, X6, #1 // Increment set counter.
CMP X6, X2 // Last set reached yet?
BLE set_loop // If not, iterate set_loop,
ADD X5, X5, #1 // else, next way.
CMP X5, X3 // Last way reached yet?
BLE way_loop // If not, iterate way_loop
```

**设置MMU：**

ARMv8-A处理器使用VMSAv8-64来执行如下操作：

1. 将物理地址转为虚拟地址
2. 决定内存属性、检查访问权限

每一个页表项是48bit，支持三种粒度的页：4KB、16KB、64KB，支持最多48bit的输入输出地址，最多支持4级的页表

**使能MMU和cache**

必须设置了SMPEN bit才能打开MMU和cache。

**使能NEON和浮点运算：**

在aarch64，你不需要使能访问NEON和FP寄存器，但是access to the NEON and FP registers can still be trapped？？

#### 改变异常级别



